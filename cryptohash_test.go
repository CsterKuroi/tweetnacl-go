package tweetnacl

import (
	"bytes"
	"testing"
)

// --- CryptoHash ---

// Adapted from tests/core1.c)
func TestCryptoHash(t *testing.T) {
	message := []byte("testing\n")

	expected := []byte{
		0x24, 0xf9, 0x50, 0xaa,
		0xc7, 0xb9, 0xea, 0x9b,
		0x3c, 0xb7, 0x28, 0x22,
		0x8a, 0x0c, 0x82, 0xb6,
		0x7c, 0x39, 0xe9, 0x6b,
		0x4b, 0x34, 0x47, 0x98,
		0x87, 0x0d, 0x5d, 0xae,
		0xe9, 0x3e, 0x3a, 0xe5,
		0x93, 0x1b, 0xaa, 0xe8,
		0xc7, 0xca, 0xcf, 0xea,
		0x4b, 0x62, 0x94, 0x52,
		0xc3, 0x80, 0x26, 0xa8,
		0x1d, 0x13, 0x8b, 0xc7,
		0xaa, 0xd1, 0xaf, 0x3e,
		0xf7, 0xbf, 0xd5, 0xec,
		0x64, 0x6d, 0x6c, 0x28}

	hash, err := CryptoHash(message)

	if err != nil {
		t.Errorf("crypto_hash: %v", err)
		return
	}

	if hash == nil {
		t.Errorf("crypto_hash: nil")
		return
	}

	if !bytes.Equal(hash, expected) {
		t.Errorf("crypto_hash: invalid SHA-512 hash (%v)", hash)
		return
	}
}

func BenchmarkCryptoHash(b *testing.B) {
	message := []byte("testing\n")

	for i := 0; i < b.N; i++ {
		CryptoHash(message)
	}
}

// --- CryptoHashBlocks ---

// There doesn't seem to be an official test so this one is worked up from
// the internal implementation of crypto_hash in tweetnacl.c.
func TestCryptoHashBlocks(t *testing.T) {
	iv := []byte{
		0x6a, 0x09, 0xe6, 0x67,
		0xf3, 0xbc, 0xc9, 0x08,
		0xbb, 0x67, 0xae, 0x85,
		0x84, 0xca, 0xa7, 0x3b,
		0x3c, 0x6e, 0xf3, 0x72,
		0xfe, 0x94, 0xf8, 0x2b,
		0xa5, 0x4f, 0xf5, 0x3a,
		0x5f, 0x1d, 0x36, 0xf1,
		0x51, 0x0e, 0x52, 0x7f,
		0xad, 0xe6, 0x82, 0xd1,
		0x9b, 0x05, 0x68, 0x8c,
		0x2b, 0x3e, 0x6c, 0x1f,
		0x1f, 0x83, 0xd9, 0xab,
		0xfb, 0x41, 0xbd, 0x6b,
		0x5b, 0xe0, 0xcd, 0x19,
		0x13, 0x7e, 0x21, 0x79}

	blocks := []byte{
		0x74, 0x65, 0x73, 0x74,
		0x69, 0x6e, 0x67, 0x0a,
		0x80, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x40}

	expected := []byte{
		0x24, 0xf9, 0x50, 0xaa,
		0xc7, 0xb9, 0xea, 0x9b,
		0x3c, 0xb7, 0x28, 0x22,
		0x8a, 0x0c, 0x82, 0xb6,
		0x7c, 0x39, 0xe9, 0x6b,
		0x4b, 0x34, 0x47, 0x98,
		0x87, 0x0d, 0x5d, 0xae,
		0xe9, 0x3e, 0x3a, 0xe5,
		0x93, 0x1b, 0xaa, 0xe8,
		0xc7, 0xca, 0xcf, 0xea,
		0x4b, 0x62, 0x94, 0x52,
		0xc3, 0x80, 0x26, 0xa8,
		0x1d, 0x13, 0x8b, 0xc7,
		0xaa, 0xd1, 0xaf, 0x3e,
		0xf7, 0xbf, 0xd5, 0xec,
		0x64, 0x6d, 0x6c, 0x28}

	hash, err := CryptoHashBlocks(iv, blocks)

	if err != nil {
		t.Errorf("crypto_hashiblocks: %v", err)
		return
	}

	if hash == nil {
		t.Errorf("crypto_hashblocks: nil")
		return
	}

	if !bytes.Equal(hash, expected) {
		t.Errorf("crypto_hashblocks: invalid SHA-512 hash (%v)", hash)
		return
	}
}

func BenchmarkCryptoHashBlocks(b *testing.B) {
	hash := []byte{
		0x6a, 0x09, 0xe6, 0x67,
		0xf3, 0xbc, 0xc9, 0x08,
		0xbb, 0x67, 0xae, 0x85,
		0x84, 0xca, 0xa7, 0x3b,
		0x3c, 0x6e, 0xf3, 0x72,
		0xfe, 0x94, 0xf8, 0x2b,
		0xa5, 0x4f, 0xf5, 0x3a,
		0x5f, 0x1d, 0x36, 0xf1,
		0x51, 0x0e, 0x52, 0x7f,
		0xad, 0xe6, 0x82, 0xd1,
		0x9b, 0x05, 0x68, 0x8c,
		0x2b, 0x3e, 0x6c, 0x1f,
		0x1f, 0x83, 0xd9, 0xab,
		0xfb, 0x41, 0xbd, 0x6b,
		0x5b, 0xe0, 0xcd, 0x19,
		0x13, 0x7e, 0x21, 0x79}

	blocks := []byte{
		0x74, 0x65, 0x73, 0x74,
		0x69, 0x6e, 0x67, 0x0a,
		0x80, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x40}

	for i := 0; i < b.N; i++ {
		hash, _ = CryptoHashBlocks(hash, blocks)
	}
}
